module GraphReduction
  ( Node(..)
  , NodeIndex
  , Graph
  , EvalStrategy(..)
  , nodes
  , rootIndex
  , firstStep
  , nextGraph
  ) where

import Data.Maybe (isJust)
import Data.Sequence (Seq, (|>))
import qualified Data.Sequence as Seq
import Control.Monad.Trans.Reader (ask, local, runReader, Reader, ReaderT(runReaderT))
import Control.Monad.Trans.State (get, modify, runState, State)
import Control.Monad.Trans.Class (lift)
import Control.Lens (makeLenses, (&), (^.), (.~), (%~))

import Parser


data Node
  = VarNode String
  | LamNode String NodeIndex
  | AppNode NodeIndex NodeIndex
  deriving (Show, Eq)

type NodeIndex = Int

data Graph = Graph
  { _nodes :: Seq Node        -- ^ all the nodes of a graph arranged in a finger tree
  , _counter :: Int           -- ^ keeps track of how many numbers have been used to rename bound variables
  , _rootIndex :: NodeIndex   -- ^ the index of the cell where the root node is located
  }
  deriving Eq

makeLenses ''Graph

data EvalStrategy
  = CallByName
  | CallByValue
  | CallByNeed
  deriving (Show, Eq)


-- | Converts digits generated by alpha renaming to subscripts for better display.
digitToSubscript :: Char -> Char
digitToSubscript '0' = '₀'
digitToSubscript '1' = '₁'
digitToSubscript '2' = '₂'
digitToSubscript '3' = '₃'
digitToSubscript '4' = '₄'
digitToSubscript '5' = '₅'
digitToSubscript '6' = '₆'
digitToSubscript '7' = '₇'
digitToSubscript '8' = '₈'
digitToSubscript '9' = '₉'
digitToSubscript c = c

-- | Performs alpha renaming to all the bound variables.
alphaRename :: Expression
            -> ReaderT 
                [(String, String)]  -- list of renamings (old name, new name)
                (State Int)         -- during renaming, the bound variable is always renamed with this counter attached to the end
                Expression          -- renamed expression
alphaRename (Var v) = do
  renamings <- ask
  case lookup v renamings of
    Nothing -> return (Var v)
    Just v' -> return (Var v')
alphaRename (Lam v e) = do
  counter <- lift get
  lift (modify (+1))
  let v' = v ++ map digitToSubscript (show counter)
  e' <- local ((v, v'):) (alphaRename e)
  return (Lam v' e')
alphaRename (App e1 e2) = App <$> alphaRename e1 <*> alphaRename e2

-- | Appends node to the end of the graph and returns the index of the new node.
addNode :: Node -> State Graph NodeIndex
addNode node = do
  modify $ nodes %~ (|> node)
  graph <- get
  return (Seq.length (graph^.nodes) - 1)

-- | Returns the node at the given index.
getNode :: NodeIndex -> State Graph Node
getNode index = do
  graph <- get
  return (Seq.index (graph^.nodes) index)

-- | Updates the old node with the new node in the graph.
updateNode :: NodeIndex -> NodeIndex -> State Graph ()
updateNode old new = do
  graph <- get
  modify $ nodes %~ Seq.update old (Seq.index (graph^.nodes) new)

-- | Copies the subgraph whose root is located at index and appends it to the end of the graph.
-- copy and copyNode are mutually recursive.
copy :: NodeIndex -> State Graph NodeIndex
copy index = do
  node <- getNode index
  copyNode node

-- | Copies a subgraph and appends it to the end of the graph.
copyNode :: Node -> State Graph NodeIndex
copyNode node@(VarNode v) = addNode node
copyNode (LamNode v e) = do
  e' <- copy e
  addNode (LamNode v e')
copyNode (AppNode e1 e2) = do
  e1' <- copy e1
  e2' <- copy e2
  addNode (AppNode e1' e2')

-- | Converts the parse tree into a graph.
astToGraph :: Expression -> State Graph NodeIndex
astToGraph (Var v) = addNode (VarNode v)
astToGraph (Lam v e) = do
  index <- astToGraph e
  addNode (LamNode v index)
astToGraph (App e1 e2) = do
  index1 <- astToGraph e1
  index2 <- astToGraph e2
  addNode (AppNode index1 index2)

-- | Checks if the subgraph contains any free occurrences of param.
ifParamInBody :: String             -- ^ the parameter of an abstraction
              -> NodeIndex          -- ^ the index of a subgraph
              -> Reader Graph Bool  -- ^ returns true if the subgraph contains free occurrences of the parameter
ifParamInBody param body = do
  graph <- ask
  case Seq.index (graph^.nodes) body of
    VarNode v -> return (v == param)
    LamNode v e -> do
      res <- ifParamInBody param e
      return $ (v /= param) && res
    AppNode e1 e2 -> do
      res1 <- ifParamInBody param e1
      res2 <- ifParamInBody param e2
      return $ res1 || res2

-- | Instantiates the lambda abstraction (performs substitution in the body for reduction).
instantiate :: String                                        -- ^ the parameter of the abstraction
            -> NodeIndex                                     -- ^ the index of the body of the abstraction
            -> NodeIndex                                     -- ^ the index of the argument
            -> ReaderT EvalStrategy (State Graph) NodeIndex  -- ^ returns the index of the instantiated body
instantiate param body arg = do
  strat <- ask
  graph <- lift get
  let paramInBody = runReader (ifParamInBody param body) graph
  if paramInBody
    then lift (getNode body) >>= \case
      VarNode v
        | v == param -> if strat == CallByNeed then return arg else lift (copy arg)
        | otherwise -> return body
      LamNode v e
        | v == param -> return body
        | otherwise -> do
            e' <- instantiate param e arg
            lift $ addNode (LamNode v e')
      AppNode e1 e2 -> do
        e1' <- instantiate param e1 arg
        e2' <- instantiate param e2 arg
        lift $ addNode (AppNode e1' e2')
    else return body

-- | Searches for redex in a graph and does one step of reduction.
-- If the reduction is successfully performed, the redex that has been reduced is returned. Otherwise Nothing is returned.
oneStepReduce :: NodeIndex -> [Definition] -> ReaderT EvalStrategy (State Graph) (Maybe NodeIndex)
oneStepReduce root defs = do
  strat <- ask
  rootNode <- lift (getNode root)
  case rootNode of
    AppNode e1 e2 -> lift (getNode e1) >>= \case
      LamNode param body -> do
        e2IsValue <- isValue <$> lift (getNode e2)
        if strat == CallByName || strat == CallByNeed || (strat == CallByValue && e2IsValue)
        then do
          inst <- instantiate param body e2
          lift $ updateNode root inst
          return (Just root)
        else oneStepReduce e2 defs
      _ -> oneStepReduce e1 defs
    VarNode v -> case lookUpInDefs v defs of
      -- v is a supercombinator
      Just bodyExpr -> do
        graph <- lift get
        -- renames the body of the supercombinator
        let (bodyExpr', counter') = runState (runReaderT (alphaRename bodyExpr) []) (graph^.counter)
        -- don't forget to update the counter, otherwise the attached subscripts in the later renamings will be off :)
        lift $ modify $ counter .~ counter'
        -- converts the definition into a graph
        body <- lift $ astToGraph bodyExpr'
        lift $ updateNode root body
        -- unfolding the definition of a supercombinator counts as one step of reduction
        return (Just root)
      Nothing -> return Nothing
    _ -> return Nothing
  where
    -- Only abstractions and variables that are not supercombinators count as values.
    isValue :: Node -> Bool
    isValue (AppNode _ _) = False
    isValue (VarNode v) = not $ isDef v defs
    isValue _ = True

    -- Checks if a name is a supercombinator. If yes, then returns its definition. Otherwise returns Nothing.
    lookUpInDefs :: String -> [Definition] -> Maybe Expression
    lookUpInDefs _ [] = Nothing
    lookUpInDefs var ((Def fun body):defs) = if var == fun then Just body else lookUpInDefs var defs

    isDef :: String -> [Definition] -> Bool
    isDef = (isJust .) . lookUpInDefs

-- | Turns an expression into a graph, does one step of reduction and returns the first two graphs.
firstStep :: EvalStrategy -> Expression -> [Definition] -> [(Maybe NodeIndex, Graph)]
firstStep strat expr defs = let
  (renamedExpr, counter) = runState (runReaderT (alphaRename expr) []) 1
  (root, graph) = runState (astToGraph renamedExpr) Graph{_nodes=Seq.empty, _counter=counter, _rootIndex=negate 1}
  graph' = graph & rootIndex .~ root
  (redex, graph'') = nextGraph strat graph' defs
  in [(redex, graph''), (Nothing, graph')]

-- | Performs one step of reduction and returns the possibly reduced graph.
nextGraph :: EvalStrategy -> Graph -> [Definition] -> (Maybe NodeIndex, Graph)
nextGraph strat graph defs = runState (runReaderT (oneStepReduce (graph^.rootIndex) defs) strat) graph